use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;
use std::process::Command;

/// Install post-commit hook in the Git repository
pub fn install_hook(repo_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut hook_path = PathBuf::from(repo_path);
    hook_path.push(".git");
    hook_path.push("hooks");
    hook_path.push("post-commit");

    // Get the absolute path to the ploop executable
    let ploop_path = std::env::current_exe()?;
    let ploop_path_str = ploop_path.to_str().ok_or("Invalid ploop path")?;

    // Create hook script
    let hook_content = format!(
        "#!/bin/sh\n\
         # ploop post-commit hook\n\
         # Auto-generated by ploop init\n\
         \n\
         {} run\n",
        ploop_path_str
    );

    // Write hook file
    fs::write(&hook_path, hook_content)?;

    // Make hook executable on Unix-like systems
    #[cfg(unix)]
    {
        let mut perms = fs::metadata(&hook_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&hook_path, perms)?;
    }

    log::info!("Post-commit hook installed at: {:?}", hook_path);
    Ok(())
}

/// Check if post-commit hook is installed
pub fn is_hook_installed(repo_path: &str) -> bool {
    let mut hook_path = PathBuf::from(repo_path);
    hook_path.push(".git");
    hook_path.push("hooks");
    hook_path.push("post-commit");

    hook_path.exists()
}

/// Remove post-commit hook
#[allow(dead_code)]
pub fn remove_hook(repo_path: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut hook_path = PathBuf::from(repo_path);
    hook_path.push(".git");
    hook_path.push("hooks");
    hook_path.push("post-commit");

    if hook_path.exists() {
        fs::remove_file(&hook_path)?;
        log::info!("Post-commit hook removed from: {:?}", hook_path);
    }

    Ok(())
}

/// Get the current commit hash
pub fn get_current_commit_hash(repo_path: &str) -> Result<String, Box<dyn std::error::Error>> {
    let output = Command::new("git")
        .current_dir(repo_path)
        .args(&["rev-parse", "HEAD"])
        .output()?;

    if !output.status.success() {
        return Err("Failed to get commit hash".into());
    }

    let hash = String::from_utf8(output.stdout)?;
    Ok(hash.trim().to_string())
}

/// Get the short commit hash (first 7 characters)
pub fn get_short_commit_hash(repo_path: &str) -> Result<String, Box<dyn std::error::Error>> {
    let hash = get_current_commit_hash(repo_path)?;
    Ok(hash.chars().take(7).collect())
}

/// Check if we're in a Git repository
pub fn is_git_repo(repo_path: &str) -> bool {
    let mut git_path = PathBuf::from(repo_path);
    git_path.push(".git");
    git_path.exists()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_git_repo() {
        // Current working directory should be a git repo
        let result = is_git_repo(".");
        assert!(result || !result); // Just test that it doesn't panic
    }
}
